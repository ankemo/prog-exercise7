n_start       <- 2                        # start of search range for primes
n_end         <- 100                      # end of search range for primes
A_prime       <- rep(TRUE, n_end)         # the array of boolean values where TRUE == prime and FALSE == no-prime
range_count   <- n_start:n_end            # multiple counter
prime_index   <- n_start:(n_end/2)        # index of primes, only neccessary until n_end/2
factor_save   <- rep(0,100)               # array of zeros covering the range factor counting
# calculate the prime and their factors
for (current_number in prime_index){
if (A_prime[current_number]) { # only evaluate if not already assigned to be non-prime
# set factors of the prime to FALSE
factorstart = current_number*2 # avoid setting prime to false
A_primemultiples = seq(factorstart,n_end,current_number)
factor_save[current_number] = length(A_primemultiples)
# if remainder of current number with any number in the range is zero, the current number is not prime
for (multiple in range_count){
if ((multiple %% current_number) == 0){
A_prime[A_primemultiples] = FALSE
}
}
}
}
# new parameters
prime_save  <- which(A_prime==TRUE)   # convert booleans to actual numbers
prime_save  <- prime_save[-1]         # remove 1, this is not a prime
factor_save <- factor_save[prime_save]   # only remember the factors of the primes
# debug: check if the same amount of elements are present
if (length(prime_save) != length(factor_save)){
print('WARNING: prime_save and factor_save do not contain the same number of elements')
}
# plot the primes and their factors within the range, give title and label
# axes
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1)
title("Prime numbers with corresponding factors", xlab = "Primes", ylab = "Factors")
# display the number of primes found, the prime numbers and the factors of
# the primes in the console
sprintf("there are %s prime numbers in total", length(prime_save))
cat("the primes are:", prime_save)
cat("their factors are:", factor_save)
# ANKE MURILLO OOSTERWIJK
# STUDENT NUMBER: 54832amu???
#
# THIS SCRIPT FINDS ALL PRIME NUMBERS IN THE SPECIFIED RANGE WITH THE SIEVE OF
# ERATOSTHENES ALGORITHM --> It initiates and array of numbers between a range
# and eliminates all non-prime prime factors (by calculating the remainder). It
# saves this prime number and subsequently calculates the factors of the prime
# to be found in the specified range.
# parameters
n_start       <- 2                        # start of search range for primes
n_end         <- 100                      # end of search range for primes
A_prime       <- rep(TRUE, n_end)         # the array of boolean values where TRUE == prime and FALSE == no-prime
range_count   <- n_start:n_end            # multiple counter
prime_index   <- n_start:(n_end/2)        # index of primes, only neccessary until n_end/2
factor_save   <- rep(0,100)               # array of zeros covering the range factor counting
# calculate the prime and their factors
for (current_number in prime_index){
if (A_prime[current_number]) { # only evaluate if not already assigned to be non-prime
# set factors of the prime to FALSE
factorstart = current_number*2 # avoid setting prime to false
A_primemultiples = seq(factorstart,n_end,current_number)
factor_save[current_number] = length(A_primemultiples)
# if remainder of current number with any number in the range is zero, the current number is not prime
for (multiple in range_count){
if ((multiple %% current_number) == 0){
A_prime[A_primemultiples] = FALSE
}
}
}
}
# new parameters
prime_save  <- which(A_prime==TRUE)   # convert booleans to actual numbers
prime_save  <- prime_save[-1]         # remove 1, this is not a prime
factor_save <- factor_save[prime_save]   # only remember the factors of the primes
# debug: check if the same amount of elements are present
if (length(prime_save) != length(factor_save)){
print('WARNING: prime_save and factor_save do not contain the same number of elements')
}
# plot the primes and their factors within the range, give title and label
# axes
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1)
title("Prime numbers with corresponding factors", xlab = "Primes", ylab = "Factors")
# display the number of primes found, the prime numbers and the factors of
# the primes in the console
sprintf("there are %s prime numbers in total", length(prime_save))
cat("the primes are:", prime_save)
cat("their factors are:", factor_save)
Clear All
clear all
clear vars
# ANKE MURILLO OOSTERWIJK
# STUDENT NUMBER: 54832amu???
#
# THIS SCRIPT FINDS ALL PRIME NUMBERS IN THE SPECIFIED RANGE WITH THE SIEVE OF
# ERATOSTHENES ALGORITHM --> It initiates and array of numbers between a range
# and eliminates all non-prime prime factors (by calculating the remainder). It
# saves this prime number and subsequently calculates the factors of the prime
# to be found in the specified range.
# parameters
n_start       <- 2                        # start of search range for primes
n_end         <- 100                      # end of search range for primes
A_prime       <- rep(TRUE, n_end)         # the array of boolean values where TRUE == prime and FALSE == no-prime
range_count   <- n_start:n_end            # multiple counter
prime_index   <- n_start:(n_end/2)        # index of primes, only neccessary until n_end/2
factor_save   <- rep(0,100)               # array of zeros covering the range factor counting
# calculate the prime and their factors
for (current_number in prime_index){
if (A_prime[current_number]) { # only evaluate if not already assigned to be non-prime
# set factors of the prime to FALSE
factorstart = current_number*2 # avoid setting prime to false
A_primemultiples = seq(factorstart,n_end,current_number)
factor_save[current_number] = length(A_primemultiples)
# if remainder of current number with any number in the range is zero, the current number is not prime
for (multiple in range_count){
if ((multiple %% current_number) == 0){
A_prime[A_primemultiples] = FALSE
}
}Clea
}
}
# ANKE MURILLO OOSTERWIJK
# STUDENT NUMBER: 54832amu???
#
# THIS SCRIPT FINDS ALL PRIME NUMBERS IN THE SPECIFIED RANGE WITH THE SIEVE OF
# ERATOSTHENES ALGORITHM --> It initiates and array of numbers between a range
# and eliminates all non-prime prime factors (by calculating the remainder). It
# saves this prime number and subsequently calculates the factors of the prime
# to be found in the specified range.
# parameters
n_start       <- 2                        # start of search range for primes
n_end         <- 100                      # end of search range for primes
A_prime       <- rep(TRUE, n_end)         # the array of boolean values where TRUE == prime and FALSE == no-prime
range_count   <- n_start:n_end            # multiple counter
prime_index   <- n_start:(n_end/2)        # index of primes, only neccessary until n_end/2
factor_save   <- rep(0,100)               # array of zeros covering the range factor counting
# calculate the prime and their factors
for (current_number in prime_index){
if (A_prime[current_number]) { # only evaluate if not already assigned to be non-prime
# set factors of the prime to FALSE
factorstart = current_number*2 # avoid setting prime to false
A_primemultiples = seq(factorstart,n_end,current_number)
factor_save[current_number] = length(A_primemultiples)
# if remainder of current number with any number in the range is zero, the current number is not prime
for (multiple in range_count){
if ((multiple %% current_number) == 0){
A_prime[A_primemultiples] = FALSE
}
}
}
}
factor_save
prime_save  <- which(A_prime==TRUE)   # convert booleans to actual numbers
prime_save  <- prime_save[-1]         # remove 1, this is not a prime
factor_save <- factor_save[prime_save]   # only remember the factors of the primes
factor_save
# ANKE MURILLO OOSTERWIJK
# STUDENT NUMBER: 54832amu
#
# THIS SCRIPT GENERATES A RANGE AND SUBSEQUENTLY CROSSES OUT ALL NON-PRIME
# NUMBERS ACCORDING TO THE SIEVE OF ERATOSTHENES ALGORITHM --> It calculates all
# non-prime prime factors by calculating remainders: if there is a remainder to
# be found of the current number with any of the numbers in the range, the current
# number is not prime. It additionally remembers how many factors of the primes
# there are to be found within the range. Lastly the primes and factors are
# shown in a bar graph and presented on the screen.
# parameters
n_start       <- 2                        # start of search range for primes
n_end         <- 100                      # end of search range for primes
A_prime       <- rep(TRUE, n_end)         # the array of boolean values where TRUE == prime and FALSE == no-prime
range_count   <- n_start:n_end            # multiple counter
prime_index   <- n_start:(n_end/2)        # index of primes, no factors >50 can be crossed out
factor_save   <- rep(0,100)               # array of zeros covering the range factor counting
# calculate the prime and their factors
for (current_number in prime_index){
if (A_prime[current_number]) { # only evaluate number if not already assigned to be non-prime
# calculate the multiples of the number
factorstart = current_number*2 # avoid setting the prime itself to false
A_primefactors = seq(factorstart,n_end,current_number)
factor_save[current_number] = length(A_primefactors)
# if remainder of current number with any number in the range is zero, the current number is not prime
for (multiple in range_count){
if ((multiple %% current_number) == 0){
A_prime[A_primefactors] = FALSE
}
}
}
}
# set new parameters for plot and display
prime_save  <- which(A_prime==TRUE)      # convert booleans to actual numbers to presnt later
prime_save  <- prime_save[-1]            # remove 1, this is not a prime
factor_save <- factor_save[prime_save]   # only the factors of the actual prime numbers are needed
# plot the primes and their factors, give title and label axes
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1)
title("Prime numbers with corresponding factors", xlab = "Primes", ylab = "Factors")
# display the number of primes found, the prime numbers and the factors of
# the primes in the console
sprintf("there are %s prime numbers in total", length(prime_save))
cat("the primes are:", prime_save)
cat("their factors are:", factor_save)
?barplot
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1, offset = -2)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1, offset = 0)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1, offset = 0, inside = FALSE)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 2)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 3)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 4)
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 5)
array1 = c(1:10)
array1
array1(-3)
array1
array1[-3]
array1
array1-2
array1
array1 = array1/3
array1
array1 = array1*3+2
array1
array1= array1[-4]
array1
array2 = array1(array1==0)
array2 = array1[array1==3]
array2
array1
array2 = array1[array1==1*]
array2 = array1[array1==1%]
array2 = array1[array1==1$]
# ANKE MURILLO OOSTERWIJK
# STUDENT NUMBER: 54832amu
#
# THIS SCRIPT GENERATES A RANGE AND SUBSEQUENTLY CROSSES OUT ALL NON-PRIME
# NUMBERS ACCORDING TO THE SIEVE OF ERATOSTHENES ALGORITHM --> It calculates all
# non-prime prime factors by calculating remainders: if there is a remainder to
# be found of the current number with any of the numbers in the range, the current
# number is not prime. It additionally remembers how many factors of the primes
# there are to be found within the range. Lastly the primes and factors are
# shown in a bar graph and presented on the screen.
# parameters
n_start       <- 2                        # start of search range for primes
n_end         <- 100                      # end of search range for primes
A_prime       <- rep(TRUE, n_end)         # the array of boolean values (TRUE == prime and FALSE == no-prime)
range_count   <- n_start:n_end            # multiple counter
prime_index   <- n_start:(n_end/2)        # index of primes, no factors >50 can be crossed out
factor_save   <- rep(0,100)               # array of zeros covering the range factor counting
# calculate the prime and their factors
for (current_number in prime_index){
if (A_prime[current_number]) { # only evaluate number if not already assigned to be non-prime
# calculate the multiples of the number
factorstart = current_number*2 # avoid setting the prime itself to false
A_primefactors = seq(factorstart,n_end,current_number)
factor_save[current_number] = length(A_primefactors)
# if remainder of current number with any number in the range is zero, the current number is not prime
for (multiple in range_count){
if ((multiple %% current_number) == 0){
A_prime[A_primefactors] = FALSE
}
}
}
}
# set new parameters to plot and display
prime_save  <- which(A_prime==TRUE)      # convert booleans to actual numbers
prime_save  <- prime_save[-1]            # remove number 1, this is not a prime
factor_save <- factor_save[prime_save]   # only the factors of the actual prime numbers are needed
# plot the primes and their factors, give title and label axes
barplot(factor_save, names.arg = prime_save, ylim = c(0,50), axis.lty = 1)
title("Prime numbers with corresponding factors", xlab = "Primes", ylab = "Factors")
# display the number of primes found, the prime numbers and the factors of
# the primes in the console
sprintf("there are %s prime numbers in total", length(prime_save))
cat("the primes are:", prime_save)
cat("their factors are:", factor_save)
length(factro_save)
length(factor_save)
length(prime_save)
?vector
A = c(1,2,3)
is.vector(A)
?c
A = matrix(c(1,2,3,4,5,6), nrow = 2)
sum(A)
sum(A, squeeze = T)
rowSums(A)
rowSums(A, squeeze = T)
sum(A, dimensions:2)
sum(A, dimensions = 2)
sum(A, dimensions = 1)
A
sum(A, dimensions = 1, squeeze = 2)
sum(A, dimensions:2)
sum(A,dimensions:2)
?sum
A <- numeric()
A
A[1:3,] = c(1,2,3)
A[1:3,] = [1,2,3]
A[1:3,] <- c(1,2,3)
A[1:3,] <- [1,2,3]
A[3] <- 4
A
A[1:3] <- c(1,2,3)
A <- numeric(3)
A
?is.value
A <- numeric()
is.vetor(A)
is.vector(A)
A
is.matrix(A)
dim(A)
B <- numeric(3)
B
dim(B)
A[1:3] <- c(1,2,3)
A
A <- numeric
a
A
A <- numeric()
A
A[1]
A[1,1]
A <- as.matrix(numeric())
A
dim(A)
A <- as.matrix(numeric(3))
A
A <- as.matrix(numeric(,3))
A <- as.matrix(numeric(,3), byrow = T)
A <- as.matrix(numeric(3), byrow = T)
A
dim(A)
A <- as.matrix(numeric(3), nrow = 1)
A
A <- as.matrix(numeric(1))
Aa
A
dim(A)
c(A,B)
?object
c(1,2,3,4,5,6,7,8,9)
A = c(1,2,3,4,5,6,7,8,9)
zinnen = rep("A", 3)
zinnen
zinnen = rep("A", 9)
expand.grid(A)
expand.grid(A,A)
sample(A)
A = c(T,F,T,T,T,F)
?numeric
mode()
A = c(1,1,1,2,2,3,3,3,4,4,5,5,5,5,6)
A
?expand.grid
sample(A)
any(A, c(1,1))
any(A, c(1,1))
?any
any(A == c(1,1))
which(A == c(1,1))
any(A == c(1,1))
c(1,1)
A
c(1,1) %in% A
which(c(1,1) %in% A)
which(c(1,2) %in% A)
which(c(5,5) %in% A)
which(c(5,5,5) %in% A)
any(c(5,5,5) %in% A)
B = sample(A)
B
any(c(5,5,5) %in% B)
B = sample(A)
B
B = sample(A)
B
any(c(5,5,5) %in% B)
c(5,5,5) %in% B
seq(1,1,1)
is(B[2], 3)
=(B[2], 3)
(B[2] == 3)
A == B
A
B
A == c(1,1,1,)
A == c(1,1,1)
A
A == c(4,4)
A == c(1,1,1)
A == c(5,5,5,5)
fill = c(T,T,F,T,T,F)
fill
ctrl = c(F,F,T,F,F,F)
tar = c(F,F,F,F,F,T)
idx_fill = c(1,2,3,4)
idx_fill
sample(idx_fill)
source('fun_AddFour.R')
getwd()
setwd("/Users/ankemo/ex7/pkg/R")
getwd()
source('fun_AddFour.R')
test_that("test_zero", {
x2 <- fun_AddTwo(0)
x4 <- fun_AddFour(0)
expect_equal(x2, 2)
expect_equal(x4, 4)
})
test_that("test_posnumber", {
x2 <- fun_AddTwo(2)
x4 <- fun_AddFour(2)
expect_equal(x2, 4)
expect_equal(x4, 6)
})
test_that("test_negnumber", {
x2 <- fun_AddTwo(-2)
x4 <- fun_AddFour(-2)
expect_equal(x2, 0)
expect_equal(x4, 2)
})
test_that("test_rowarray", {
x2 <- fun_AddTwo(c(2,4))
x4 <- fun_AddFour(c(2,4))
expect_equal(x2, c(4,6))
expect_equal(x4, c(6,8))
})
test_that("test_colarray", {
x2 <- fun_AddTwo(t(c(2,4)))
x4 <- fun_AddFour(t(c(2,4)))
expect_equal(x2, t(c(4,6)))
expect_equal(x4, t(c(6,8)))
})
test_that("test_matrix", {
x2 <- fun_AddTwo(matrix(c(2,4,6,8),nrow = 2, byrow = T))
x4 <- fun_AddFour(matrix(c(2,4,6,8),nrow = 2, byrow = T))
expect_equal(x2, matrix(c(4,6,8,10), nrow = 2, byrow = T))
expect_equal(x4, matrix(c(6,8,10,12), nrow = 2, byrow = T))
})
library('testthat')
test_that("test_zero", {
x2 <- fun_AddTwo(0)
x4 <- fun_AddFour(0)
expect_equal(x2, 2)
expect_equal(x4, 4)
})
test_that("test_posnumber", {
x2 <- fun_AddTwo(2)
x4 <- fun_AddFour(2)
expect_equal(x2, 4)
expect_equal(x4, 6)
})
test_that("test_negnumber", {
x2 <- fun_AddTwo(-2)
x4 <- fun_AddFour(-2)
expect_equal(x2, 0)
expect_equal(x4, 2)
})
test_that("test_rowarray", {
x2 <- fun_AddTwo(c(2,4))
x4 <- fun_AddFour(c(2,4))
expect_equal(x2, c(4,6))
expect_equal(x4, c(6,8))
})
test_that("test_colarray", {
x2 <- fun_AddTwo(t(c(2,4)))
x4 <- fun_AddFour(t(c(2,4)))
expect_equal(x2, t(c(4,6)))
expect_equal(x4, t(c(6,8)))
})
test_that("test_matrix", {
x2 <- fun_AddTwo(matrix(c(2,4,6,8),nrow = 2, byrow = T))
x4 <- fun_AddFour(matrix(c(2,4,6,8),nrow = 2, byrow = T))
expect_equal(x2, matrix(c(4,6,8,10), nrow = 2, byrow = T))
expect_equal(x4, matrix(c(6,8,10,12), nrow = 2, byrow = T))
})
source('fun_AddTwo.R')
test_that("test_zero", {
x2 <- fun_AddTwo(0)
x4 <- fun_AddFour(0)
expect_equal(x2, 2)
expect_equal(x4, 4)
})
test_that("test_posnumber", {
x2 <- fun_AddTwo(2)
x4 <- fun_AddFour(2)
expect_equal(x2, 4)
expect_equal(x4, 6)
})
test_that("test_negnumber", {
x2 <- fun_AddTwo(-2)
x4 <- fun_AddFour(-2)
expect_equal(x2, 0)
expect_equal(x4, 2)
})
test_that("test_rowarray", {
x2 <- fun_AddTwo(c(2,4))
x4 <- fun_AddFour(c(2,4))
expect_equal(x2, c(4,6))
expect_equal(x4, c(6,8))
})
test_that("test_colarray", {
x2 <- fun_AddTwo(t(c(2,4)))
x4 <- fun_AddFour(t(c(2,4)))
expect_equal(x2, t(c(4,6)))
expect_equal(x4, t(c(6,8)))
})
test_that("test_matrix", {
x2 <- fun_AddTwo(matrix(c(2,4,6,8),nrow = 2, byrow = T))
x4 <- fun_AddFour(matrix(c(2,4,6,8),nrow = 2, byrow = T))
expect_equal(x2, matrix(c(4,6,8,10), nrow = 2, byrow = T))
expect_equal(x4, matrix(c(6,8,10,12), nrow = 2, byrow = T))
})
